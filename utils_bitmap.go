package main

import (
	"image"
)

// ==========================================
// TEXT-TO-BITMAP RENDERING
// ==========================================

// Basic 5x7 font for text rendering to bitmap
// Each character is represented as 5 bytes (columns), 7 bits tall
var font5x7 = map[rune][]byte{
	' ': {0x00, 0x00, 0x00, 0x00, 0x00},
	'A': {0x7C, 0x12, 0x11, 0x12, 0x7C},
	'B': {0x7F, 0x49, 0x49, 0x49, 0x36},
	'C': {0x3E, 0x41, 0x41, 0x41, 0x22},
	'D': {0x7F, 0x41, 0x41, 0x22, 0x1C},
	'E': {0x7F, 0x49, 0x49, 0x49, 0x41},
	'F': {0x7F, 0x09, 0x09, 0x09, 0x01},
	'G': {0x3E, 0x41, 0x49, 0x49, 0x7A},
	'H': {0x7F, 0x08, 0x08, 0x08, 0x7F},
	'I': {0x00, 0x41, 0x7F, 0x41, 0x00},
	'J': {0x20, 0x40, 0x41, 0x3F, 0x01},
	'K': {0x7F, 0x08, 0x14, 0x22, 0x41},
	'L': {0x7F, 0x40, 0x40, 0x40, 0x40},
	'M': {0x7F, 0x02, 0x0C, 0x02, 0x7F},
	'N': {0x7F, 0x04, 0x08, 0x10, 0x7F},
	'O': {0x3E, 0x41, 0x41, 0x41, 0x3E},
	'P': {0x7F, 0x09, 0x09, 0x09, 0x06},
	'Q': {0x3E, 0x41, 0x51, 0x21, 0x5E},
	'R': {0x7F, 0x09, 0x19, 0x29, 0x46},
	'S': {0x46, 0x49, 0x49, 0x49, 0x31},
	'T': {0x01, 0x01, 0x7F, 0x01, 0x01},
	'U': {0x3F, 0x40, 0x40, 0x40, 0x3F},
	'V': {0x1F, 0x20, 0x40, 0x20, 0x1F},
	'W': {0x3F, 0x40, 0x38, 0x40, 0x3F},
	'X': {0x63, 0x14, 0x08, 0x14, 0x63},
	'Y': {0x07, 0x08, 0x70, 0x08, 0x07},
	'Z': {0x61, 0x51, 0x49, 0x45, 0x43},
	'a': {0x20, 0x54, 0x54, 0x54, 0x78},
	'b': {0x7F, 0x48, 0x44, 0x44, 0x38},
	'c': {0x38, 0x44, 0x44, 0x44, 0x20},
	'd': {0x38, 0x44, 0x44, 0x48, 0x7F},
	'e': {0x38, 0x54, 0x54, 0x54, 0x18},
	'f': {0x08, 0x7E, 0x09, 0x01, 0x02},
	'g': {0x0C, 0x52, 0x52, 0x52, 0x3E},
	'h': {0x7F, 0x08, 0x04, 0x04, 0x78},
	'i': {0x00, 0x44, 0x7D, 0x40, 0x00},
	'j': {0x20, 0x40, 0x44, 0x3D, 0x00},
	'k': {0x7F, 0x10, 0x28, 0x44, 0x00},
	'l': {0x00, 0x41, 0x7F, 0x40, 0x00},
	'm': {0x7C, 0x04, 0x18, 0x04, 0x78},
	'n': {0x7C, 0x08, 0x04, 0x04, 0x78},
	'o': {0x38, 0x44, 0x44, 0x44, 0x38},
	'p': {0x7C, 0x14, 0x14, 0x14, 0x08},
	'q': {0x08, 0x14, 0x14, 0x18, 0x7C},
	'r': {0x7C, 0x08, 0x04, 0x04, 0x08},
	's': {0x48, 0x54, 0x54, 0x54, 0x20},
	't': {0x04, 0x3F, 0x44, 0x40, 0x20},
	'u': {0x3C, 0x40, 0x40, 0x20, 0x7C},
	'v': {0x1C, 0x20, 0x40, 0x20, 0x1C},
	'w': {0x3C, 0x40, 0x30, 0x40, 0x3C},
	'x': {0x44, 0x28, 0x10, 0x28, 0x44},
	'y': {0x0C, 0x50, 0x50, 0x50, 0x3C},
	'z': {0x44, 0x64, 0x54, 0x4C, 0x44},
	'0': {0x3E, 0x51, 0x49, 0x45, 0x3E},
	'1': {0x00, 0x42, 0x7F, 0x40, 0x00},
	'2': {0x42, 0x61, 0x51, 0x49, 0x46},
	'3': {0x21, 0x41, 0x45, 0x4B, 0x31},
	'4': {0x18, 0x14, 0x12, 0x7F, 0x10},
	'5': {0x27, 0x45, 0x45, 0x45, 0x39},
	'6': {0x3C, 0x4A, 0x49, 0x49, 0x30},
	'7': {0x01, 0x71, 0x09, 0x05, 0x03},
	'8': {0x36, 0x49, 0x49, 0x49, 0x36},
	'9': {0x06, 0x49, 0x49, 0x29, 0x1E},
	'!': {0x00, 0x00, 0x5F, 0x00, 0x00},
	'?': {0x02, 0x01, 0x51, 0x09, 0x06},
	'.': {0x00, 0x60, 0x60, 0x00, 0x00},
	',': {0x00, 0x80, 0x60, 0x00, 0x00},
	':': {0x00, 0x36, 0x36, 0x00, 0x00},
	'-': {0x08, 0x08, 0x08, 0x08, 0x08},
	'_': {0x40, 0x40, 0x40, 0x40, 0x40},
	'(': {0x00, 0x1C, 0x22, 0x41, 0x00},
	')': {0x00, 0x41, 0x22, 0x1C, 0x00},
	'/': {0x60, 0x10, 0x08, 0x04, 0x03},
	'@': {0x3E, 0x41, 0x5D, 0x55, 0x1E},
	// Additional special characters (Issue 15)
	'%':  {0x23, 0x13, 0x08, 0x64, 0x62},
	'+':  {0x08, 0x08, 0x3E, 0x08, 0x08},
	'=':  {0x14, 0x14, 0x14, 0x14, 0x14},
	'<':  {0x08, 0x14, 0x22, 0x41, 0x00},
	'>':  {0x00, 0x41, 0x22, 0x14, 0x08},
	'#':  {0x14, 0x7F, 0x14, 0x7F, 0x14},
	'*':  {0x22, 0x14, 0x7F, 0x14, 0x22},
	'&':  {0x36, 0x49, 0x55, 0x22, 0x50},
	'[':  {0x00, 0x7F, 0x41, 0x41, 0x00},
	']':  {0x00, 0x41, 0x41, 0x7F, 0x00},
	';':  {0x00, 0x80, 0x56, 0x00, 0x00},
	'\'': {0x00, 0x00, 0x07, 0x00, 0x00},
	'"':  {0x00, 0x07, 0x00, 0x07, 0x00},
}

// ==========================================
// DISPLAY SCALE HELPERS
// ==========================================

// getScaledTextSize returns the text size adjusted for the current display scale
// Input baseSize is typically 1 or 2, output is clamped to 1-3 (ESP32 font limits)
func getScaledTextSize(baseSize int) int {
	switch displayScale {
	case "compact":
		// Reduce size by 1, minimum 1
		if baseSize <= 1 {
			return 1
		}
		return baseSize - 1
	case "large":
		// Increase size by 1, maximum 3
		if baseSize >= 3 {
			return 3
		}
		return baseSize + 1
	default: // "normal"
		return baseSize
	}
}

// getScaleMultiplier returns the scale factor for bitmaps
// Returns: 0.75 for compact, 1.0 for normal, 1.5 for large
func getScaleMultiplier() float64 {
	switch displayScale {
	case "compact":
		return 0.75
	case "large":
		return 1.5
	default:
		return 1.0
	}
}

// getScaledBitmapSize returns the target bitmap dimensions adjusted for scale
// Ensures the result fits within OLED bounds (128x64)
func getScaledBitmapSize(baseWidth, baseHeight int) (int, int) {
	mult := getScaleMultiplier()
	newWidth := int(float64(baseWidth) * mult)
	newHeight := int(float64(baseHeight) * mult)

	// Clamp to OLED dimensions
	if newWidth > 128 {
		newWidth = 128
	}
	if newHeight > 64 {
		newHeight = 64
	}
	// Minimum size
	if newWidth < 8 {
		newWidth = 8
	}
	if newHeight < 8 {
		newHeight = 8
	}
	return newWidth, newHeight
}

// calcCenteredX calculates the X position to center text on a 128-pixel wide OLED
// Text width = charCount * 5 * size + (charCount - 1) * size (no trailing space)
func calcCenteredX(text string, size int) int {
	charCount := len([]rune(text))
	if charCount <= 0 {
		return 64 // Default to center
	}
	textWidth := charCount*5*size + (charCount-1)*size
	x := (128 - textWidth) / 2
	if x < 0 {
		x = 0
	}
	return x
}

// convertFrameToBitmap converts a frame with text/line elements to a frame with a single bitmap element
func convertFrameToBitmap(frame Frame) Frame {
	const width = 128
	const height = 64
	bytesPerRow := (width + 7) / 8 // 16 bytes per row for 128 width
	bitmap := make([]int, bytesPerRow*height)

	// Helper function to set a pixel
	setPixel := func(px, py int) {
		if px < 0 || px >= width || py < 0 || py >= height {
			return
		}
		byteIndex := py*bytesPerRow + px/8
		if byteIndex < len(bitmap) {
			bitmap[byteIndex] |= (0x80 >> (px % 8))
		}
	}

	// Render all elements
	for _, el := range frame.Elements {
		switch el.Type {
		case "text":
			// Render text element
			currentX := el.X
			size := el.Size
			if size == 0 {
				size = 1
			}
			for _, char := range el.Value {
				charData, exists := font5x7[char]
				if !exists {
					charData = font5x7[' '] // Default to space
				}
				// Draw character with scaling
				for col := 0; col < 5; col++ {
					for row := 0; row < 7; row++ {
						if charData[col]&(1<<row) != 0 {
							for sx := 0; sx < size; sx++ {
								for sy := 0; sy < size; sy++ {
									setPixel(currentX+col*size+sx, el.Y+row*size+sy)
								}
							}
						}
					}
				}
				currentX += 6 * size
				if currentX >= width {
					break
				}
			}

		case "line":
			// Render line/rectangle element
			for x := el.X; x < el.X+el.Width; x++ {
				for y := el.Y; y < el.Y+el.Height; y++ {
					setPixel(x, y)
				}
			}
		}
	}

	// Return new frame with bitmap element
	return Frame{
		Version:  frame.Version,
		Duration: frame.Duration,
		Clear:    frame.Clear,
		Elements: []Element{
			{
				Type:   "bitmap",
				X:      0,
				Y:      0,
				Width:  128,
				Height: 64,
				Bitmap: bitmap,
			},
		},
	}
}

// ==========================================
// IMAGE PROCESSING
// ==========================================

func processImageToBitmap(src image.Image, width, height int) []int {
	bounds := src.Bounds()
	dx := bounds.Dx()
	dy := bounds.Dy()

	bytesPerRow := (width + 7) / 8
	finalBitmap := make([]int, bytesPerRow*height)

	targetW, targetH := width, height
	ratioSrc := float64(dx) / float64(dy)
	ratioDst := float64(width) / float64(height)

	if ratioSrc > ratioDst {
		targetH = int(float64(width) / ratioSrc)
	} else {
		targetW = int(float64(height) * ratioSrc)
	}

	offsetX := (width - targetW) / 2
	offsetY := (height - targetH) / 2

	for y := 0; y < targetH; y++ {
		for x := 0; x < targetW; x++ {
			srcX := int(float64(x) * float64(dx) / float64(targetW))
			srcY := int(float64(y) * float64(dy) / float64(targetH))

			r, g, b, _ := src.At(bounds.Min.X+srcX, bounds.Min.Y+srcY).RGBA()
			lum := (19595*r + 38470*g + 7471*b + 1<<15) >> 24

			if lum > 128 {
				drawX := x + offsetX
				drawY := y + offsetY

				byteIndex := drawY*bytesPerRow + drawX/8
				if byteIndex < len(finalBitmap) {
					finalBitmap[byteIndex] |= (0x80 >> (drawX % 8))
				}
			}
		}
	}

	return finalBitmap
}
